<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0066)http://www.seas.upenn.edu/~cis194/spring13/lectures/12-monads.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>12-monads</title>

  <script type="text/javascript" src="./12-monads_files/MathJax.js"></script>
  <link href="./12-monads_files/style.css" rel="stylesheet" type="text/css">
<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
<body><div id="MathJax_Message" style="display: none;"></div>

  <div id="canvas">
    <div id="nav"><p><strong>CIS 194</strong>: <a href="http://www.seas.upenn.edu/~cis194/spring13/">Home</a> | <a href="http://www.seas.upenn.edu/~cis194/spring13/lectures.html">Lectures &amp; Assignments</a> | <a href="http://www.seas.upenn.edu/~cis194/spring13/policies.html">Policies</a> | <a href="http://www.seas.upenn.edu/~cis194/spring13/resources.html">Resources</a> | <a href="http://www.seas.upenn.edu/~cis194/spring13/final.html">Final Project</a></p></div>

    <div id="content">
      
      <p><!-- CLASS

> import Control.Monad
> import Control.Applicative

--></p>
<h1 id="monads">Monads</h1>
<p>CIS 194 Week 12<br>8 April 2013</p>
<p>Suggested reading:</p>
<ul>
<li><a href="http://www.haskell.org/haskellwiki/Typeclassopedia">The Typeclassopedia</a></li>
<li><a href="http://learnyouahaskell.com/a-fistful-of-monads">LYAH Chapter 12: A Fistful of Monads</a></li>
<li><a href="http://learnyouahaskell.com/input-and-output">LYAH Chapter 9: Input and Output</a></li>
<li><a href="http://book.realworldhaskell.org/read/io.html">RWH Chapter 7: I/O</a></li>
<li><a href="http://book.realworldhaskell.org/read/monads.html">RWH Chapter 14: Monads</a></li>
<li><a href="http://book.realworldhaskell.org/read/programming-with-monads.html">RWH Chapter 15: Programming with monads</a></li>
</ul>
<h2 id="motivation">Motivation</h2>
<p>Over the last couple of weeks, we have seen how the <code>Applicative</code> class allows us to idiomatically handle computations which take place in some sort of “special context”—for example, taking into account possible failure with <code>Maybe</code>, multiple possible outputs with <code>[]</code>, consulting some sort of environment using <code>((-&gt;) e)</code>, or construct parsers using a “combinator” approach, as in the homework.</p>
<p>However, so far we have only seen computations with a fixed structure, such as applying a data constructor to a fixed set of arguments. What if we don’t know the structure of the computation in advance – that is, we want to be able to decide what to do based on some intermediate results?</p>
<p>As an example, recall the <code>Parser</code> type from the homework, and assume that we have implemented <code>Functor</code> and <code>Applicative</code> instances for it:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">Parser</span> {<span class="ot"> runParser ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">String</span>) }</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Parser</span> <span class="kw">where</span>
  <span class="fu">...</span>

<span class="kw">instance</span> <span class="kw">Applicative</span> <span class="dt">Parser</span> <span class="kw">where</span>
  <span class="fu">...</span></code></pre>
<p>Recall that a value of type <code>Parser a</code> represents a <em>parser</em> which can take a <code>String</code> as input and possibly produce a value of type <code>a</code>, along with the remaining unparsed portion of the <code>String</code>. For example, a parser for integers, given as input the string</p>
<pre><code>"143xkkj"
</code></pre>
<p>might produce as output</p>
<pre><code>Just (143, "xkkj")
</code></pre>
<p>As you saw in the homework, we can now write things like</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Foo</span> <span class="fu">=</span> <span class="dt">Bar</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Char</span>

<span class="ot">parseFoo ::</span> <span class="dt">Parser</span> <span class="dt">Foo</span>
parseFoo <span class="fu">=</span> <span class="dt">Bar</span> <span class="fu">&lt;$&gt;</span> parseInt <span class="fu">&lt;*&gt;</span> parseInt <span class="fu">&lt;*&gt;</span> parseChar</code></pre>
<p>assuming we have functions <code>parseInt :: Parser Int</code> and <code>parseChar :: Parser Char</code>. The <code>Applicative</code> instance automatically handles the possible failure (if parsing any of the components fail, parsing the entire <code>Foo</code> will fail) and threading through the unconsumed portion of the <code>String</code> input to each component in turn.</p>
<p>However, suppose we are trying to parse a file containing a sequence of numbers, like this:</p>
<pre><code>4 78 19 3 44 3 1 7 5 2 3 2
</code></pre>
<p>The catch is that the first number in the file tells us the length of a following “group” of numbers; the next number after the group is the length of the next group, and so on. So the example above could be broken up into groups like this:</p>
<pre><code>78 19 3 44   -- first group
1 7 5        -- second group
3 2          -- third group
</code></pre>
<p>This is a somewhat contrived example, but in fact there are many “real-world” file formats that follow a similar principle—you read some sort of header which then tells you the lengths of some following blocks, or where to find things in the file, and so on.</p>
<p>We would like to write a parser for this file format of type</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseFile ::</span> <span class="dt">Parser</span> [[<span class="dt">Int</span>]]</code></pre>
<p>Unfortunately, this is not possible using only the <code>Applicative</code> interface. The problem is that <code>Applicative</code> gives us no way to decide what to do next based on previous results: we must decide in advance what parsing operations we are going to run, before we see the results.</p>
<p>It turns out, however, that the <code>Parser</code> type <em>can</em> support this sort of pattern, which is abstracted into the <code>Monad</code> type class.</p>
<h2 id="monad">Monad</h2>
<p>The <code>Monad</code> type class is defined as follows:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Monad</span> m <span class="kw">where</span>
<span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a

<span class="ot">  (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b

<span class="ot">  (&gt;&gt;)  ::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b
  m1 <span class="fu">&gt;&gt;</span> m2 <span class="fu">=</span> m1 <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> m2</code></pre>
<p>This should look familiar! We have seen these methods before in the context of <code>IO</code>, but in fact they are not specific to <code>IO</code> at all. It’s just that a monadic interface to <code>IO</code> has proved useful.</p>
<p><code>return</code> also looks familiar because it has the same type as <code>pure</code>. In fact, every <code>Monad</code> should also be an <code>Applicative</code>, with <code>pure = return</code>. The reason we have both is that <code>Applicative</code> was invented <em>after</em> <code>Monad</code> had already been around for a while.</p>
<p><code>(&gt;&gt;)</code> is just a specialized version of <code>(&gt;&gt;=)</code> (it is included in the <code>Monad</code> class in case some instance wants to provide a more efficient implementation, but usually the default implementation is just fine). So to understand it we first need to understand <code>(&gt;&gt;=)</code>.</p>
<p>There is actually a fourth method called <code>fail</code>, but putting it in the <code>Monad</code> class was a mistake, and you should never use it, so I won’t tell you about it (you can <a href="http://www.haskell.org/haskellwiki/Typeclassopedia#do_notation">read about it in the Typeclassopedia</a> if you are interested).</p>
<p><code>(&gt;&gt;=)</code> (pronounced “bind”) is where all the action is! Let’s think carefully about its type:</p>
<pre><code>(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
</code></pre>
<p><code>(&gt;&gt;=)</code> takes two arguments. The first one is a value of type <code>m a</code>. (Incidentally, such values are sometimes called <em>monadic values</em>, or <em>computations</em>. It has also been proposed to call them <em>mobits</em>. The one thing you must <em>not</em> call them is “monads”, since that is a kind error: the type constructor <code>m</code> is a monad.) In any case, the idea is that a mobit of type <code>m a</code> represents a computation which results in a value (or several values, or no values) of type <code>a</code>, and may also have some sort of “effect”:</p>
<ul>
<li><p><code>c1 :: Maybe a</code> is a computation which might fail but results in an <code>a</code> if it succeeds.</p></li>
<li><p><code>c2 :: [a]</code> is a computation which results in (multiple) <code>a</code>s.</p></li>
<li><p><code>c3 :: Parser a</code> is a computation which implicitly consumes part of a <code>String</code> and (possibly) produces an <code>a</code>.</p></li>
<li><p><code>c4 :: IO a</code> is a computation which potentially has some I/O effects and then produces an <code>a</code>.</p></li>
</ul>
<p>And so on. Now, what about the second argument to <code>(&gt;&gt;=)</code>? It is a <em>function</em> of type <code>(a -&gt; m b)</code>. That is, it is a function which will <em>choose</em> the next computation to run based on the result(s) of the first computation. This is precisely what embodies the promised power of <code>Monad</code> to encapsulate computations which can choose what to do next based on the results of previous computations.</p>
<p>So all <code>(&gt;&gt;=)</code> really does is put together two mobits to produce a larger one, which first runs one and then the other, returning the result of the second one. The all-important twist is that we get to decide which mobit to run second based on the output from the first.</p>
<p>The default implementation of <code>(&gt;&gt;)</code> should make sense now:</p>
<pre><code>(&gt;&gt;)  :: m a -&gt; m b -&gt; m b
m1 &gt;&gt; m2 = m1 &gt;&gt;= \_ -&gt; m2
</code></pre>
<p><code>m1 &gt;&gt; m2</code> simply does <code>m1</code> and then <code>m2</code>, ignoring the result of <code>m1</code>.</p>
<h2 id="examples">Examples</h2>
<p>Let’s start by writing a <code>Monad</code> instance for <code>Maybe</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  <span class="fu">return</span>  <span class="fu">=</span> <span class="kw">Just</span>
  <span class="kw">Nothing</span> <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> <span class="kw">Nothing</span>
  <span class="kw">Just</span> x  <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> k x</code></pre>
<p><code>return</code>, of course, is <code>Just</code>. If the first argument of <code>(&gt;&gt;=)</code> is <code>Nothing</code>, then the whole computation fails; otherwise, if it is <code>Just x</code>, we apply the second argument to <code>x</code> to decide what to do next.</p>
<p>Incidentally, it is common to use the letter <code>k</code> for the second argument of <code>(&gt;&gt;=)</code> because <code>k</code> stands for “continuation”. I wish I was joking.</p>
<p>Some examples:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">check ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
check n <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">10</span>    <span class="fu">=</span> <span class="kw">Just</span> n
        <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="kw">Nothing</span>

<span class="ot">halve ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
halve n <span class="fu">|</span> <span class="fu">even</span> n    <span class="fu">=</span> <span class="kw">Just</span> <span class="fu">$</span> n <span class="ot">`div`</span> <span class="dv">2</span>
        <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="kw">Nothing</span>

ex01 <span class="fu">=</span> <span class="fu">return</span> <span class="dv">7</span> <span class="fu">&gt;&gt;=</span> check <span class="fu">&gt;&gt;=</span> halve
ex02 <span class="fu">=</span> <span class="fu">return</span> <span class="dv">12</span> <span class="fu">&gt;&gt;=</span> check <span class="fu">&gt;&gt;=</span> halve
ex03 <span class="fu">=</span> <span class="fu">return</span> <span class="dv">12</span> <span class="fu">&gt;&gt;=</span> halve <span class="fu">&gt;&gt;=</span> check</code></pre>
<p>How about a <code>Monad</code> instance for the list constructor <code>[]</code>?</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> [] <span class="kw">where</span>
  <span class="fu">return</span> x <span class="fu">=</span> [x]
  xs <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> <span class="fu">concat</span> (<span class="fu">map</span> k xs)</code></pre>
<p>A simple example:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">addOneOrTwo ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
addOneOrTwo x <span class="fu">=</span> [x<span class="fu">+</span><span class="dv">1</span>, x<span class="fu">+</span><span class="dv">2</span>]

ex04 <span class="fu">=</span> [<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>] <span class="fu">&gt;&gt;=</span> addOneOrTwo</code></pre>
<h2 id="monad-combinators">Monad combinators</h2>
<p>One nice thing about the <code>Monad</code> class is that using only <code>return</code> and <code>(&gt;&gt;=)</code> we can build up a lot of nice general combinators for programming with monads. Let’s look at a couple.</p>
<p>First, <code>sequence</code> takes a list of monadic values and produces a single monadic value which collects the results. What this means depends on the particular monad. For example, in the case of <code>Maybe</code> it means that the entire computation succeeds only if all the individual ones do; in the case of <code>IO</code> it means to run all the computations in sequence; in the case of <code>Parser</code> it means to run all the parsers on sequential parts of the input (and succeed only if they all do).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">sequence</span><span class="ot"> ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> [m a] <span class="ot">-&gt;</span> m [a]
<span class="fu">sequence</span> [] <span class="fu">=</span> <span class="fu">return</span> []
<span class="fu">sequence</span> (ma<span class="fu">:</span>mas) <span class="fu">=</span>
  ma <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span>
  <span class="fu">sequence</span> mas <span class="fu">&gt;&gt;=</span> \as <span class="ot">-&gt;</span>
  <span class="fu">return</span> (a<span class="fu">:</span>as)</code></pre>
<p>Using <code>sequence</code> we can also write other combinators, such as</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">replicateM ::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m [a]
replicateM n m <span class="fu">=</span> <span class="fu">sequence</span> (<span class="fu">replicate</span> n m)</code></pre>
<p>And now we are finally in a position to write the parser we wanted to write: it is simply</p>
<pre><code>parseFile :: Parser [[Int]]
parseFile = many parseLine

parseLine :: Parser [Int]
parseLine = parseInt &gt;&gt;= \i -&gt; replicateM i parseInt
</code></pre>
<p>(<code>many</code> was also known as <code>zeroOrMore</code> on the homework).</p>
<p><!--

Local Variables:
mode:markdown
compile-command:"make explec"
End:

--></p>
<hr>
<p><code>Generated 2013-04-04 15:32:20.090162</code></p>

    </div>

    <div id="footer"><center>
      <font size="-2">Powered
      by <a href="http://community.haskell.org/~ndm/shake/">shake</a>,
      <a href="http://jaspervdj.be/hakyll/index.html">hakyll</a>,
      and <a href="http://johnmacfarlane.net/pandoc/">pandoc</a>.
      </font></center><font size="-2">
    </font></div><font size="-2">
  </font></div><font size="-2">



</font></body></html>