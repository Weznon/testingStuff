<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0072)http://www.seas.upenn.edu/~cis194/spring13/lectures/11-applicative2.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>11-applicative2</title>

  <script type="text/javascript" src="./11-applicative2_files/MathJax.js"></script>
  <link href="./11-applicative2_files/style.css" rel="stylesheet" type="text/css">
<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
<body><div id="MathJax_Message" style="display: none;"></div>

  <div id="canvas">
    <div id="nav"><p><strong>CIS 194</strong>: <a href="http://www.seas.upenn.edu/~cis194/spring13/">Home</a> | <a href="http://www.seas.upenn.edu/~cis194/spring13/lectures.html">Lectures &amp; Assignments</a> | <a href="http://www.seas.upenn.edu/~cis194/spring13/policies.html">Policies</a> | <a href="http://www.seas.upenn.edu/~cis194/spring13/resources.html">Resources</a> | <a href="http://www.seas.upenn.edu/~cis194/spring13/final.html">Final Project</a></p></div>

    <div id="content">
      
      <h1 id="applicative-functors-part-ii">Applicative functors, Part II</h1>
<p>CIS 194 Week 11<br>1 April 2012</p>
<p>Suggested reading:</p>
<ul>
<li><a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors">Applicative Functors</a> from Learn You a Haskell</li>
<li><a href="http://www.haskell.org/haskellwiki/Typeclassopedia">The Typeclassopedia</a></li>
</ul>
<p>We begin with a review of the <code>Functor</code> and <code>Applicative</code> type classes:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> f <span class="kw">where</span>
<span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b

<span class="kw">class</span> <span class="kw">Functor</span> f <span class="ot">=&gt;</span> <span class="kw">Applicative</span> f <span class="kw">where</span>
<span class="ot">  pure  ::</span> a <span class="ot">-&gt;</span> f a
<span class="ot">  (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p>Every <code>Applicative</code> is also a <code>Functor</code>—so can we implement <code>fmap</code> in terms of <code>pure</code> and <code>(&lt;*&gt;)</code>? Let’s try!</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">fmap</span> g x <span class="fu">=</span> pure g <span class="fu">&lt;*&gt;</span> x</code></pre>
<p>Well, that has the right type at least! However, it’s not hard to imagine making <code>Functor</code> and <code>Applicative</code> instances for some type such that this equality does not hold. Since this would be a fairly dubious situation, we stipulate as a <em>law</em> that this equality must hold—this is a formal way of stating that the <code>Functor</code> and <code>Applicative</code> instances for a given type must “play nicely together”.</p>
<p>Now, let’s see a few more examples of <code>Applicative</code> instances.</p>
<h2 id="more-applicative-examples">More Applicative Examples</h2>
<p><strong>Lists</strong></p>
<p>How about an instance of <code>Applicative</code> for lists? There are actually two possible instances: one that matches up the list of functions and list of arguments elementwise (that is, it “zips” them together), and one that combines functions and arguments in all possible ways.</p>
<p>First, let’s write the instance that does all possible combinations. (For reasons that will become clear next week, this is the default instance.) From this point of view, lists represent nondeterminism: that is, a value of type <code>[a]</code> can be thought of as a single value with multiple possibilities. Then <code>(&lt;*&gt;)</code> corresponds to nondeterministic function application—that is, the application of a nondeterministic function to a nondeterministic argument.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Applicative</span> [] <span class="kw">where</span>
  pure a        <span class="fu">=</span> [a]          <span class="co">-- a "deterministic" value</span>
  [] <span class="fu">&lt;*&gt;</span> _      <span class="fu">=</span> []
  (f<span class="fu">:</span>fs) <span class="fu">&lt;*&gt;</span> as <span class="fu">=</span> (<span class="fu">map</span> f as) <span class="fu">++</span> (fs <span class="fu">&lt;*&gt;</span> as)</code></pre>
<p>Here’s an example:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">names  <span class="fu">=</span> [<span class="st">"Joe"</span>, <span class="st">"Sara"</span>, <span class="st">"Mae"</span>]
phones <span class="fu">=</span> [<span class="st">"555-5555"</span>, <span class="st">"123-456-7890"</span>, <span class="st">"555-4321"</span>]

employees1 <span class="fu">=</span> <span class="dt">Employee</span> <span class="fu">&lt;$&gt;</span> names <span class="fu">&lt;*&gt;</span> phones</code></pre>
<p>Maybe this particular example doesn’t make that much sense, but it’s not hard to imagine situations where you want to combine things in all possible ways like this. For example, we can do nondeterministic arithmetic like so:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">(<span class="fu">.+</span>) <span class="fu">=</span> liftA2 (<span class="fu">+</span>)    <span class="co">-- addition lifted to some Applicative context</span>
(<span class="fu">.*</span>) <span class="fu">=</span> liftA2 (<span class="fu">*</span>)    <span class="co">-- same for multiplication</span>

<span class="co">-- nondeterministic arithmetic</span>
n <span class="fu">=</span> ([<span class="dv">4</span>,<span class="dv">5</span>] <span class="fu">.*</span> pure <span class="dv">2</span>) <span class="fu">.+</span> [<span class="dv">6</span>,<span class="dv">1</span>] <span class="co">-- (either 4 or 5) times 2, plus either 6 or 1</span>

<span class="co">-- and some possibly-failing arithmetic too, just for fun</span>
m1 <span class="fu">=</span> (<span class="kw">Just</span> <span class="dv">3</span> <span class="fu">.+</span> <span class="kw">Just</span> <span class="dv">5</span>) <span class="fu">.*</span> <span class="kw">Just</span> <span class="dv">8</span>
m2 <span class="fu">=</span> (<span class="kw">Just</span> <span class="dv">3</span> <span class="fu">.+</span> <span class="kw">Nothing</span>) <span class="fu">.*</span> <span class="kw">Just</span> <span class="dv">8</span></code></pre>
<p>Next, let’s write the instance that does elementwise combining. First, we must answer an important question: how should we handle lists of different lengths? Some thought reveals that the most sensible thing to do is to truncate the longer list to the length of the shorter, throwing away the extra elements. Of course there are other possible answers: we might, for instance, extend the shorter list by copying the last element (but then what do we do when one of the lists is empty?); or extend the shorter list with a “neutral” element (but then we would have to require an instance of <code>Monoid</code>, or an extra “default” argument for the application).</p>
<p>This decision in turn dictates how we must implement <code>pure</code>, since we must obey the law</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">pure f <span class="fu">&lt;*&gt;</span> xs <span class="fu">===</span> f <span class="fu">&lt;$&gt;</span> xs</code></pre>
<p>Notice that the right-hand side is a list with the same length as <code>xs</code>, formed by applying <code>f</code> to every element in <code>xs</code>. The only way we can make the left-hand side turn out the same… is for <code>pure</code> to create an infinite list of copies of <code>f</code>, because we don’t know in advance how long <code>xs</code> is going to be.</p>
<p>We implement the instance using a <code>newtype</code> wrapper to distinguish it from the other list instance. The standard Prelude function <code>zipWith</code> also comes in handy.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ZipList</span> a <span class="fu">=</span> <span class="dt">ZipList</span> {<span class="ot"> getZipList ::</span> [a] }
  <span class="kw">deriving</span> (<span class="kw">Eq</span>, <span class="kw">Show</span>, <span class="kw">Functor</span>)

<span class="kw">instance</span> <span class="kw">Applicative</span> <span class="dt">ZipList</span> <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="dt">ZipList</span> <span class="fu">.</span> <span class="fu">repeat</span>
  <span class="dt">ZipList</span> fs <span class="fu">&lt;*&gt;</span> <span class="dt">ZipList</span> xs <span class="fu">=</span> <span class="dt">ZipList</span> (<span class="fu">zipWith</span> (<span class="fu">$</span>) fs xs)</code></pre>
<p>An example:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">employees2 <span class="fu">=</span> getZipList <span class="fu">$</span> <span class="dt">Employee</span> <span class="fu">&lt;$&gt;</span> <span class="dt">ZipList</span> names <span class="fu">&lt;*&gt;</span> <span class="dt">ZipList</span> phones</code></pre>
<p><strong>Reader/environment</strong></p>
<p>Let’s do one final example instance, for <code>(-&gt;) e</code>. This is known as the <em>reader</em> or <em>environment</em> applicative, since it allows “reading” from the “environment” <code>e</code>. Implementing the instance is not too hard, we just have to use our nose and follow the types:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> ((<span class="ot">-&gt;</span>) e) <span class="kw">where</span>
  <span class="fu">fmap</span> <span class="fu">=</span> (<span class="fu">.</span>)

<span class="kw">instance</span> <span class="kw">Applicative</span> ((<span class="ot">-&gt;</span>) e) <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="fu">const</span>
  f <span class="fu">&lt;*&gt;</span> x <span class="fu">=</span> \e <span class="ot">-&gt;</span> (f e) (x e)</code></pre>
<p>An <code>Employee</code> example:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BigRecord</span> <span class="fu">=</span> <span class="dt">BR</span> {<span class="ot"> getName         ::</span> <span class="dt">Name</span>
                    ,<span class="ot"> getSSN          ::</span> <span class="dt">String</span>
                    ,<span class="ot"> getSalary       ::</span> <span class="dt">Integer</span>
                    ,<span class="ot"> getPhone        ::</span> <span class="dt">String</span>
                    ,<span class="ot"> getLicensePlate ::</span> <span class="dt">String</span>
                    ,<span class="ot"> getNumSickDays  ::</span> <span class="dt">Int</span>
                    }

r <span class="fu">=</span> <span class="dt">BR</span> <span class="st">"Brent"</span> <span class="st">"XXX-XX-XXX4"</span> <span class="dv">600000000</span> <span class="st">"555-1234"</span> <span class="st">"JGX-55T3"</span> <span class="dv">2</span>

<span class="ot">getEmp ::</span> <span class="dt">BigRecord</span> <span class="ot">-&gt;</span> <span class="dt">Employee</span>
getEmp <span class="fu">=</span> <span class="dt">Employee</span> <span class="fu">&lt;$&gt;</span> getName <span class="fu">&lt;*&gt;</span> getPhone

ex01 <span class="fu">=</span> getEmp r</code></pre>
<h2 id="aside-levels-of-abstraction">Aside: Levels of Abstraction</h2>
<p><code>Functor</code> is a nifty tool but relatively straightforward. At first glance it seems like <code>Applicative</code> doesn’t add that much beyond what <code>Functor</code> already provides, but it turns out that it’s a small addition with a huge impact. <code>Applicative</code> (and as we will see next week, <code>Monad</code>) deserves to be called a “model of computation”, while <code>Functor</code> doesn’t.</p>
<p>When working with things like <code>Applicative</code> and <code>Monad</code>, it’s very important to keep in mind that there are <em>multiple levels of abstraction</em> involved. Roughly speaking, an <em>abstraction</em> is something which <em>hides details</em> of a lower level, providing a “high-level” interface that can be used (ideally) without thinking about the lower level—although the details of the lower level often “leak through” in certain cases. This idea of layers of abstraction is widespread. Think about user programs—OS—kernel—integrated circuits—gates—silicon, or HTTP—TCP—IP—Ethernet, or programming languages—bytecode—assembly—machine code. As we have seen, Haskell gives us many nice tools for constructing multiple layers of abstraction <em>within Haskell programs themselves</em>, that is, we get to dynamically extend the “programming language” layer stack upwards. This is a powerful facility but can lead to confusion. One must learn to explicitly be able to think on multiple levels, and to switch between levels.</p>
<p>With respect to <code>Applicative</code> and <code>Monad</code> in particular, there are just two levels to be concerned with. The first is the level of implementing various <code>Applicative</code> and <code>Monad</code> instances, <em>i.e.</em> the “raw Haskell” level. You gained some experience with this level in your previous homework, when you implemented an <code>Applicative</code> instance for <code>Parser</code>.</p>
<p>Once we have an <code>Applicative</code> instance for a type like <code>Parser</code>, the point is that we get to “move up a layer” and program with <code>Parser</code>s <em>using the <code>Applicative</code> interface</em>, without thinking about the details of how <code>Parser</code> and its <code>Applicative</code> instance are actually implemented. You got a little bit of experience with this on last week’s homework, and will get a lot more of it this week. Programming at this level has a very different feel than actually implementing the instances. Let’s see some examples.</p>
<h2 id="the-applicative-api">The Applicative API</h2>
<p>One of the benefits of having a unified interface like <code>Applicative</code> is that we can write generic tools and control structures that work with <em>any</em> type which is an instance of <code>Applicative</code>. As a first example, let’s try writing</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">pair ::</span> <span class="kw">Applicative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f (a,b)</code></pre>
<p><code>pair</code> takes two values and pairs them, but all in the context of some <code>Applicative f</code>. As a first try we can take a function for pairing and “lift” it over the arguments using <code>(&lt;$&gt;)</code> and <code>(&lt;*&gt;)</code>:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">pair fa fb <span class="fu">=</span> (\x y <span class="ot">-&gt;</span> (x,y)) <span class="fu">&lt;$&gt;</span> fa <span class="fu">&lt;*&gt;</span> fb</code></pre>
<p>This works, though we can simplify it a bit. First, note that Haskell allows the special syntax <code>(,)</code> to represent the pair constructor, so we can write</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">pair fa fb <span class="fu">=</span> (,) <span class="fu">&lt;$&gt;</span> fa <span class="fu">&lt;*&gt;</span> fb</code></pre>
<p>But actually, we’ve seen this pattern before—this is the <code>liftA2</code> pattern which got us started down this whole <code>Applicative</code> road. So we can further simplify to</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">pair fa fb <span class="fu">=</span> liftA2 (,) fa fb</code></pre>
<p>but now there is no need to explicitly write out the function arguments, so we reach our final simplified version:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">pair <span class="fu">=</span> liftA2 (,)</code></pre>
<p>Now, what does this function do? It depends, of course, on the particular <code>f</code> chosen. Let’s consider a number of particular examples:</p>
<ul>
<li><code>f = Maybe</code>: the result is <code>Nothing</code> if either of the arguments is; if both are <code>Just</code> the result is <code>Just</code> their pairing.</li>
<li><code>f = []</code>: <code>pair</code> computes the Cartesian product of two lists.</li>
<li><code>f = ZipList</code>: <code>pair</code> is the same as the standard <code>zip</code> function.</li>
<li><code>f = IO</code>: <code>pair</code> runs two <code>IO</code> actions in sequence, returning a pair of their results.</li>
<li><code>f = Parser</code>: <code>pair</code> runs two parsers in sequence (the parsers consume consecutive sections of the input), returning their results as a pair. If either parser fails, the whole thing fails.</li>
</ul>
<p>Can you implement the following functions? Consider what each function does when <code>f</code> is replaced with each of the above types.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">(*&gt;)       ::</span> <span class="kw">Applicative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f b
<span class="ot">mapA       ::</span> <span class="kw">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> f [b])
<span class="ot">sequenceA  ::</span> <span class="kw">Applicative</span> f <span class="ot">=&gt;</span> [f a] <span class="ot">-&gt;</span> f [a]
<span class="ot">replicateA ::</span> <span class="kw">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f [a]</code></pre>
<p><!--

Local Variables:
mode:markdown
compile-command:"mk pre"
End:

--></p>
<hr>
<p><code>Generated 2013-04-04 15:15:39.334627</code></p>

    </div>

    <div id="footer"><center>
      <font size="-2">Powered
      by <a href="http://community.haskell.org/~ndm/shake/">shake</a>,
      <a href="http://jaspervdj.be/hakyll/index.html">hakyll</a>,
      and <a href="http://johnmacfarlane.net/pandoc/">pandoc</a>.
      </font></center><font size="-2">
    </font></div><font size="-2">
  </font></div><font size="-2">



</font></body></html>