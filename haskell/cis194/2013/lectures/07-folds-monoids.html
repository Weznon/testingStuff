<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0073)http://www.seas.upenn.edu/~cis194/spring13/lectures/07-folds-monoids.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>07-folds-monoids</title>

  <script type="text/javascript" src="./07-folds-monoids_files/MathJax.js"></script>
  <link href="./07-folds-monoids_files/style.css" rel="stylesheet" type="text/css">
<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
<body><div id="MathJax_Message" style="display: none;"></div>

  <div id="canvas">
    <div id="nav"><p><strong>CIS 194</strong>: <a href="http://www.seas.upenn.edu/~cis194/spring13/">Home</a> | <a href="http://www.seas.upenn.edu/~cis194/spring13/lectures.html">Lectures &amp; Assignments</a> | <a href="http://www.seas.upenn.edu/~cis194/spring13/policies.html">Policies</a> | <a href="http://www.seas.upenn.edu/~cis194/spring13/resources.html">Resources</a> | <a href="http://www.seas.upenn.edu/~cis194/spring13/final.html">Final Project</a></p></div>

    <div id="content">
      
      <p><!-- CLASS
 
> {-# OPTIONS_GHC -Wall #-}
> {-# LANGUAGE GeneralizedNewtypeDeriving #-}

--></p>
<h1 id="folds-and-monoids">Folds and monoids</h1>
<p>CIS 194 Week 7<br>25 February 2013</p>
<p>Suggested reading:</p>
<ul>
<li>Learn You a Haskell, <a href="http://learnyouahaskell.com/higher-order-functions#folds">Only folds and horses</a></li>
<li>Learn You a Haskell, <a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#monoids">Monoids</a></li>
<li><a href="http://haskell.org/haskellwiki/Fold">Fold</a> from the Haskell wiki</li>
<li>Heinrich Apfelmus, <a href="http://apfelmus.nfshost.com/articles/monoid-fingertree.html">Monoids and Finger Trees</a></li>
<li>Dan Piponi, <a href="http://blog.sigfpe.com/2009/01/haskell-monoids-and-their-uses.html">Haskell Monoids and their Uses</a></li>
<li><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html">Data.Monoid documentation</a></li>
<li><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html">Data.Foldable documentation</a></li>
</ul>
<h2 id="folds-again">Folds, again</h2>
<p>We’ve already seen how to define a folding function for lists… but we can generalize the idea to other data types as well!</p>
<p>Consider the following data type of binary trees with data stored at internal nodes:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Empty</span>
            <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> a) a (<span class="dt">Tree</span> a)
  <span class="kw">deriving</span> (<span class="kw">Show</span>, <span class="kw">Eq</span>)

<span class="ot">leaf ::</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a
leaf x <span class="fu">=</span> <span class="dt">Node</span> <span class="dt">Empty</span> x <span class="dt">Empty</span></code></pre>
<p>Let’s write a function to compute the size of a tree (<em>i.e.</em> the number of <code>Node</code>s):</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">treeSize ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span>
treeSize <span class="dt">Empty</span>        <span class="fu">=</span> <span class="dv">0</span>
treeSize (<span class="dt">Node</span> l _ r) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> treeSize l <span class="fu">+</span> treeSize r</code></pre>
<p>How about the sum of the data in a tree of <code>Integer</code>s?</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">treeSum ::</span> <span class="dt">Tree</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
treeSum <span class="dt">Empty</span>     <span class="fu">=</span> <span class="dv">0</span>
treeSum (<span class="dt">Node</span> l x r)  <span class="fu">=</span> x <span class="fu">+</span> treeSum l <span class="fu">+</span> treeSum r</code></pre>
<p>Or the depth of a tree?</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">treeDepth ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span>
treeDepth <span class="dt">Empty</span>        <span class="fu">=</span> <span class="dv">0</span>
treeDepth (<span class="dt">Node</span> l _ r) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="fu">max</span> (treeDepth l) (treeDepth r)</code></pre>
<p>Or flattening the elements of the tree into a list?</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">flatten ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]
flatten <span class="dt">Empty</span>        <span class="fu">=</span> []
flatten (<span class="dt">Node</span> l x r) <span class="fu">=</span> flatten l <span class="fu">++</span> [x] <span class="fu">++</span> flatten r</code></pre>
<p>Are you starting to see any patterns? Each of the above functions:</p>
<ol style="list-style-type: decimal">
<li>takes a <code>Tree</code> as input</li>
<li>pattern-matches on the input <code>Tree</code></li>
<li>in the <code>Empty</code> case, gives a simple answer</li>
<li>in the <code>Node</code> case:
<ol style="list-style-type: decimal">
<li>calls itself recursively on both subtrees</li>
<li>somehow combines the results from the recursive calls with the data <code>x</code> to produce the final result</li>
</ol></li>
</ol>
<p>As good programmers, we always strive to abstract out repeating patterns, right? So let’s generalize. We’ll need to pass as parameters the parts of the above examples which change from example to example:</p>
<ol style="list-style-type: decimal">
<li>The return type</li>
<li>The answer in the <code>Empty</code> case</li>
<li>How to combine the recursive calls</li>
</ol>
<p>We’ll call the type of data contained in the tree <code>a</code>, and the type of the result <code>b</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">treeFold ::</span> b <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> b
treeFold e _ <span class="dt">Empty</span>        <span class="fu">=</span> e
treeFold e f (<span class="dt">Node</span> l x r) <span class="fu">=</span> f (treeFold e f l) x (treeFold e f r)</code></pre>
<p>Now we should be able to define <code>treeSize</code>, <code>treeSum</code> and the other examples much more simply. Let’s try:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">treeSize' ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span>
treeSize' <span class="fu">=</span> treeFold <span class="dv">0</span> (\l _ r <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">+</span> l <span class="fu">+</span> r)

<span class="ot">treeSum' ::</span> <span class="dt">Tree</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
treeSum' <span class="fu">=</span> treeFold <span class="dv">0</span> (\l x r <span class="ot">-&gt;</span> l <span class="fu">+</span> x <span class="fu">+</span> r)

<span class="ot">treeDepth' ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span>
treeDepth' <span class="fu">=</span> treeFold <span class="dv">0</span> (\l _ r <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">+</span> <span class="fu">max</span> l r)

<span class="ot">flatten' ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]
flatten' <span class="fu">=</span> treeFold [] (\l x r <span class="ot">-&gt;</span> l <span class="fu">++</span> [x] <span class="fu">++</span> r)</code></pre>
<p>We can write new tree-folding functions easily as well:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">treeMax ::</span> (<span class="kw">Ord</span> a, <span class="kw">Bounded</span> a) <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> a
treeMax <span class="fu">=</span> treeFold <span class="fu">minBound</span> (\l x r <span class="ot">-&gt;</span> l <span class="ot">`max`</span> x <span class="ot">`max`</span> r)</code></pre>
<p>Much better!</p>
<p><strong>Folding expressions</strong></p>
<p>Where else have we seen folds?</p>
<p>Recall the <code>ExprT</code> type and corresponding <code>eval</code> function from Homework 5:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ExprT</span> <span class="fu">=</span> <span class="dt">Lit</span> <span class="dt">Integer</span>
           <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">ExprT</span> <span class="dt">ExprT</span>
           <span class="fu">|</span> <span class="dt">Mul</span> <span class="dt">ExprT</span> <span class="dt">ExprT</span>

<span class="ot">eval ::</span> <span class="dt">ExprT</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
eval (<span class="dt">Lit</span> i)     <span class="fu">=</span> i
eval (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> eval e1 <span class="fu">+</span> eval e2
eval (<span class="dt">Mul</span> e1 e2) <span class="fu">=</span> eval e1 <span class="fu">*</span> eval e2</code></pre>
<p>Hmm… this looks familiar! What would a fold for <code>ExprT</code> look like?</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">exprTFold ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">ExprT</span> <span class="ot">-&gt;</span> b
exprTFold f _ _ (<span class="dt">Lit</span> i)     <span class="fu">=</span> f i
exprTFold f g h (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> g (exprTFold f g h e1) (exprTFold f g h e2)
exprTFold f g h (<span class="dt">Mul</span> e1 e2) <span class="fu">=</span> h (exprTFold f g h e1) (exprTFold f g h e2)

<span class="ot">eval2 ::</span> <span class="dt">ExprT</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
eval2 <span class="fu">=</span> exprTFold <span class="fu">id</span> (<span class="fu">+</span>) (<span class="fu">*</span>)</code></pre>
<p>Now we can easily do other things like count the number of literals in an expression:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">numLiterals ::</span> <span class="dt">ExprT</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
numLiterals <span class="fu">=</span> exprTFold (<span class="fu">const</span> <span class="dv">1</span>) (<span class="fu">+</span>) (<span class="fu">+</span>)</code></pre>
<p><strong>Folds in general</strong></p>
<p>The take-away message is that we can implement a fold for many (though not all) data types. The fold for <code>T</code> will take one (higher-order) argument for each of <code>T</code>’s constructors, encoding how to turn the values stored by that constructor into a value of the result type—assuming that any recursive occurrences of <code>T</code> have already been folded into a result. Many functions we might want to write on <code>T</code> will end up being expressible as simple folds.</p>
<h2 id="monoids">Monoids</h2>
<p>Here’s another standard type class you should know about, found in the <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html"><code>Data.Monoid</code></a> module:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monoid</span> m <span class="kw">where</span>
<span class="ot">    mempty  ::</span> m
<span class="ot">    mappend ::</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m

<span class="ot">    mconcat ::</span> [m] <span class="ot">-&gt;</span> m
    mconcat <span class="fu">=</span> <span class="fu">foldr</span> mappend mempty

<span class="ot">(&lt;&gt;) ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m
(<span class="fu">&lt;&gt;</span>) <span class="fu">=</span> mappend</code></pre>
<p><code>(&lt;&gt;)</code> is defined as a synonym for <code>mappend</code> (as of GHC 7.4.1) simply because writing <code>mappend</code> is tedious.</p>
<p>Types which are instances of <code>Monoid</code> have a special element called <code>mempty</code>, and a binary operation <code>mappend</code> (abbreviated <code>(&lt;&gt;)</code>) which takes two values of the type and produces another one. The intention is that <code>mempty</code> is an identity for <code>&lt;&gt;</code>, and <code>&lt;&gt;</code> is associative; that is, for all <code>x</code>, <code>y</code>, and <code>z</code>,</p>
<ol style="list-style-type: decimal">
<li><code>mempty &lt;&gt; x == x</code></li>
<li><code>x &lt;&gt; mempty == x</code></li>
<li><code>(x &lt;&gt; y) &lt;&gt; z == x &lt;&gt; (y &lt;&gt; z)</code></li>
</ol>
<p>The associativity law means that we can unambiguously write things like</p>
<p><code>a &lt;&gt; b &lt;&gt; c &lt;&gt; d &lt;&gt; e</code></p>
<p>because we will get the same result no matter how we parenthesize.</p>
<p>There is also <code>mconcat</code>, for combining a whole list of values. By default it is implemented using <code>foldr</code>, but it is included in the <code>Monoid</code> class since particular instances of <code>Monoid</code> may have more efficient ways of implementing it.</p>
<p><code>Monoid</code>s show up <em>everywhere</em>, once you know to look for them. Let’s write some instances (just for practice; these are all in the standard libraries).</p>
<p>Lists form a monoid under concatenation:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monoid</span> [a] <span class="kw">where</span>
  mempty  <span class="fu">=</span> []
  mappend <span class="fu">=</span> (<span class="fu">++</span>)</code></pre>
<p>As hinted above, addition defines a perfectly good monoid on integers (or rational numbers, or real numbers…). However, so does multiplication! What to do? We can’t give two different instances of the same type class to the same type. Instead, we create two <code>newtype</code>s, one for each instance:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Sum</span> a <span class="fu">=</span> <span class="dt">Sum</span> a
  <span class="kw">deriving</span> (<span class="kw">Eq</span>, <span class="kw">Ord</span>, <span class="kw">Num</span>, <span class="kw">Show</span>)

<span class="ot">getSum ::</span> <span class="dt">Sum</span> a <span class="ot">-&gt;</span> a
getSum (<span class="dt">Sum</span> a) <span class="fu">=</span> a

<span class="kw">instance</span> <span class="kw">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Sum</span> a) <span class="kw">where</span>
  mempty  <span class="fu">=</span> <span class="dt">Sum</span> <span class="dv">0</span>
  mappend <span class="fu">=</span> (<span class="fu">+</span>)

<span class="kw">newtype</span> <span class="dt">Product</span> a <span class="fu">=</span> <span class="dt">Product</span> a
  <span class="kw">deriving</span> (<span class="kw">Eq</span>, <span class="kw">Ord</span>, <span class="kw">Num</span>, <span class="kw">Show</span>)

<span class="ot">getProduct ::</span> <span class="dt">Product</span> a <span class="ot">-&gt;</span> a
getProduct (<span class="dt">Product</span> a) <span class="fu">=</span> a

<span class="kw">instance</span> <span class="kw">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Product</span> a) <span class="kw">where</span>
  mempty  <span class="fu">=</span> <span class="dt">Product</span> <span class="dv">1</span>
  mappend <span class="fu">=</span> (<span class="fu">*</span>)</code></pre>
<p>Note that to find, say, the product of a list of <code>Integer</code>s using <code>mconcat</code>, we have to first turn them into values of type <code>Product Integer</code>:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">lst ::</span> [<span class="dt">Integer</span>]
lst <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">8</span>,<span class="dv">23</span>,<span class="dv">423</span>,<span class="dv">99</span>]

<span class="ot">prod ::</span> <span class="dt">Integer</span>
prod <span class="fu">=</span> getProduct <span class="fu">.</span> mconcat <span class="fu">.</span> <span class="fu">map</span> <span class="dt">Product</span> <span class="fu">$</span> lst</code></pre>
<p>(Of course, this particular example is silly, since we could use the standard <code>product</code> function instead, but this pattern does come in handy somtimes.)</p>
<p>Pairs form a monoid as long as the individual components do:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Monoid</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (a,b) <span class="kw">where</span>
  mempty <span class="fu">=</span> (mempty, mempty)
  (a,b) <span class="ot">`mappend`</span> (c,d) <span class="fu">=</span> (a <span class="ot">`mappend`</span> c, b <span class="ot">`mappend`</span> d)</code></pre>
<p>Challenge: can you make an instance of <code>Monoid</code> for <code>Bool</code>? How many different instances are there?</p>
<p>Challenge: how would you make function types an instance of <code>Monoid</code>?</p>
<p><!--

Local Variables:
mode:markdown
compile-command:"make explec"
End:

--></p>
<hr>
<p><code>Generated 2013-03-14 14:39:58.103139</code></p>

    </div>

    <div id="footer"><center>
      <font size="-2">Powered
      by <a href="http://community.haskell.org/~ndm/shake/">shake</a>,
      <a href="http://jaspervdj.be/hakyll/index.html">hakyll</a>,
      and <a href="http://johnmacfarlane.net/pandoc/">pandoc</a>.
      </font></center><font size="-2">
    </font></div><font size="-2">
  </font></div><font size="-2">



</font></body></html>