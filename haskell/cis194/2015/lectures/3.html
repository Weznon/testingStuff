<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0055)http://www.seas.upenn.edu/~cis194/lectures/03-ADTs.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>CIS194</title>

  <script type="text/javascript" src="./3_files/MathJax.js"></script>
  <link href="./3_files/style.css" rel="stylesheet" type="text/css">
<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
<body><div id="MathJax_Message" style="display: none;"></div>

  <div id="canvas">
    <div id="nav"><p><strong>CIS 194</strong>: <a href="http://www.seas.upenn.edu/~cis194/">Home</a> | <a href="http://www.seas.upenn.edu/~cis194/lectures.html">Lectures &amp; Assignments</a> | <a href="http://www.seas.upenn.edu/~cis194/policies.html">Policies</a> | <a href="http://www.seas.upenn.edu/~cis194/resources.html">Resources</a> | <a href="http://www.seas.upenn.edu/~cis194/final.html">Final Project</a> | <a href="http://www.seas.upenn.edu/~cis194/fall14/">Older version</a></p></div>

    <div id="content">
      
      <h1 id="algebraic-data-types">Algebraic data types</h1>
<p>CIS 194 Week 3 4 February 2015</p>
<p>Suggested reading:</p>
<ul>
<li><a href="http://book.realworldhaskell.org/">Real World Haskell</a>, chapters 2 - 4.</li>
</ul>
<h2 id="libraries">Libraries</h2>
<p>Haskell comes equipped with a great standard library that can be accessed from any Haskell program. Haskell libraries are distributed in <em>packages</em>, each of which can contain any number of <em>modules</em>. A vanilla Haskell installation comes with the <code>base</code> package, among a few others. The <code>base</code> package contains the <code>Prelude</code> module, which contains definitions that are automatically available in any Haskell program. The <code>base</code> package also contains many other useful modules, which can be imported with a statement like this:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Char</span> ( toUpper )</code></pre>
<p>That line imports the <code>Data.Char</code> module, but only grabs the definition for <code>toUpper</code>, as we’ll use below. The parenthesized bit is optional; if it is left out, all definitions from the imported module are brought in. You can read documentation for the <code>base</code> package on <a href="http://hackage.haskell.org/">Hackage</a> – search for <code>base</code>. Of particular use toward the beginning of the course is the <code>Data.List</code> module.</p>
<p>Haskell also provides a facility to (somewhat) easily download and install new packages to use. <a href="http://hackage.haskell.org/">Hackage</a> is the main distribution server for these packages, and <code>cabal</code> is a program, installed with the Haskell Platform, that pulls packages down from this server and installs them. Here is how you do it at a command prompt:</p>
<pre><code>~&gt; cabal update
~&gt; cabal install text-1.1.1.3
</code></pre>
<p>The first line instructs <code>cabal</code> to download an updated list of available packages; the second line installs version 1.1.1.3 of the <code>text</code> package. You can leave the version number out; that will install the most recent version. The <code>text</code> package provides a way to store chunks of text (strings, essentially) that is considerably more efficient than <code>String</code>. These instructions tell you to use version 1.1.1.3 because the most recent version, 1.2.0.0, is not compatible with some other packages you might want to install later on.</p>
<h2 id="enumeration-types">Enumeration types</h2>
<p>Like many programming languages, Haskell allows programmers to create their own <em>enumeration</em> types. Here’s a simple example:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Thing</span> <span class="fu">=</span> <span class="dt">Shoe</span> 
           <span class="fu">|</span> <span class="dt">Ship</span> 
           <span class="fu">|</span> <span class="dt">SealingWax</span> 
           <span class="fu">|</span> <span class="dt">Cabbage</span> 
           <span class="fu">|</span> <span class="dt">King</span>
  <span class="kw">deriving</span> <span class="dt">Show</span></code></pre>
<p>This declares a new type called <code>Thing</code> with five <em>data constructors</em> <code>Shoe</code>, <code>Ship</code>, etc. which are the (only) values of type <code>Thing</code>. (The <code>deriving Show</code> is a magical incantation which tells GHC to automatically generate default code for converting <code>Thing</code>s to <code>String</code>s. This is what <code>ghci</code> uses when printing the value of an expression of type <code>Thing</code>.)</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">shoe ::</span> <span class="dt">Thing</span>
shoe <span class="fu">=</span> <span class="dt">Shoe</span>

<span class="ot">listO'Things ::</span> [<span class="dt">Thing</span>]
listO'Things <span class="fu">=</span> [<span class="dt">Shoe</span>, <span class="dt">SealingWax</span>, <span class="dt">King</span>, <span class="dt">Cabbage</span>, <span class="dt">King</span>]</code></pre>
<p>We can write functions on <code>Thing</code>s by <em>pattern-matching</em>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">isSmall ::</span> <span class="dt">Thing</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isSmall <span class="dt">Shoe</span>       <span class="fu">=</span> <span class="dt">True</span>
isSmall <span class="dt">Ship</span>       <span class="fu">=</span> <span class="dt">False</span>
isSmall <span class="dt">SealingWax</span> <span class="fu">=</span> <span class="dt">True</span>
isSmall <span class="dt">Cabbage</span>    <span class="fu">=</span> <span class="dt">True</span>
isSmall <span class="dt">King</span>       <span class="fu">=</span> <span class="dt">False</span></code></pre>
<p>Recalling how function clauses are tried in order from top to bottom, we could also make the definition of <code>isSmall</code> a bit shorter like so:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">isSmall2 ::</span> <span class="dt">Thing</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isSmall2 <span class="dt">Ship</span> <span class="fu">=</span> <span class="dt">False</span>
isSmall2 <span class="dt">King</span> <span class="fu">=</span> <span class="dt">False</span>
isSmall2 _    <span class="fu">=</span> <span class="dt">True</span></code></pre>
<h2 id="beyond-enumerations">Beyond enumerations</h2>
<p><code>Thing</code> is an <em>enumeration type</em>, similar to those provided by other languages such as Java or C++. However, enumerations are actually only a special case of Haskell’s more general <em>algebraic data types</em>. As a first example of a data type which is not just an enumeration, consider the definition of <code>FailableDouble</code>:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">FailableDouble</span> <span class="fu">=</span> <span class="dt">Failure</span>
                    <span class="fu">|</span> <span class="dt">OK</span> <span class="dt">Double</span>
  <span class="kw">deriving</span> <span class="dt">Show</span></code></pre>
<p>This says that the <code>FailableDouble</code> type has two data constructors. The first one, <code>Failure</code>, takes no arguments, so <code>Failure</code> by itself is a value of type <code>FailableDouble</code>. The second one, <code>OK</code>, takes an argument of type <code>Double</code>. So <code>OK</code> by itself is not a value of type <code>FailableDouble</code>; we need to give it a <code>Double</code>. For example, <code>OK 3.4</code> is a value of type <code>FailableDouble</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">ex01 <span class="fu">=</span> <span class="dt">Failure</span>
ex02 <span class="fu">=</span> <span class="dt">OK</span> <span class="fl">3.4</span></code></pre>
<p>Thought exercise: what is the type of <code>OK</code>?</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">safeDiv ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">FailableDouble</span>
safeDiv _ <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Failure</span>
safeDiv x y <span class="fu">=</span> <span class="dt">OK</span> (x <span class="fu">/</span> y)</code></pre>
<p>More pattern-matching! Notice how in the <code>OK</code> case we can give a name to the <code>Double</code> that comes along with it.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">failureToZero ::</span> <span class="dt">FailableDouble</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
failureToZero <span class="dt">Failure</span> <span class="fu">=</span> <span class="dv">0</span>
failureToZero (<span class="dt">OK</span> d)  <span class="fu">=</span> d</code></pre>
<p>Data constructors can have more than one argument.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- Store a person's name, age, and favorite Thing.</span>
<span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> <span class="dt">String</span> <span class="dt">Int</span> <span class="dt">Thing</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="ot">richard ::</span> <span class="dt">Person</span>
richard <span class="fu">=</span> <span class="dt">Person</span> <span class="st">"Richard"</span> <span class="dv">32</span> <span class="dt">Ship</span>

<span class="ot">stan ::</span> <span class="dt">Person</span>
stan  <span class="fu">=</span> <span class="dt">Person</span> <span class="st">"Stan"</span> <span class="dv">94</span> <span class="dt">Cabbage</span>

<span class="ot">getAge ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
getAge (<span class="dt">Person</span> _ a _) <span class="fu">=</span> a</code></pre>
<p>Notice how the type constructor and data constructor are both named <code>Person</code>, but they inhabit different namespaces and are different things. This idiom (giving the type and data constructor of a one-constructor type the same name) is common, but can be confusing until you get used to it.</p>
<h2 id="algebraic-data-types-in-general">Algebraic data types in general</h2>
<p>In general, an algebraic data type has one or more data constructors, and each data constructor can have zero or more arguments.</p>
<pre><code>data AlgDataType = Constr1 Type11 Type12
                 | Constr2 Type21
                 | Constr3 Type31 Type32 Type33
                 | Constr4
</code></pre>
<p>This specifies that a value of type <code>AlgDataType</code> can be constructed in one of four ways: using <code>Constr1</code>, <code>Constr2</code>, <code>Constr3</code>, or <code>Constr4</code>. Depending on the constructor used, an <code>AlgDataType</code> value may contain some other values. For example, if it was constructed using <code>Constr1</code>, then it comes along with two values, one of type <code>Type11</code> and one of type <code>Type12</code>.</p>
<p>One final note: type and data constructor names must always start with a capital letter; variables (including names of functions) must always start with a lowercase letter. (Otherwise, Haskell parsers would have quite a difficult job figuring out which names represent variables and which represent constructors).</p>
<h2 id="pattern-matching">Pattern-matching</h2>
<p>We’ve seen pattern-matching in a few specific cases, but let’s see how pattern-matching works in general. Fundamentally, pattern-matching is about taking apart a value by <em>finding out which constructor</em> it was built with. This information can be used as the basis for deciding what to do—indeed, in Haskell, this is the <em>only</em> way to make a decision.</p>
<p>For example, to decide what to do with a value of type <code>AlgDataType</code> (the made-up type defined in the previous section), we could write something like</p>
<pre><code>foo (Constr1 a b)   = ...
foo (Constr2 a)     = ...
foo (Constr3 a b c) = ...
foo Constr4         = ...
</code></pre>
<p>Note how we also get to give names to the values that come along with each constructor. Note also that parentheses are required around patterns consisting of more than just a single constructor.</p>
<p>This is the main idea behind patterns, but there are a few more things to note.</p>
<ol style="list-style-type: decimal">
<li><p>An underscore <code>_</code> can be used as a “wildcard pattern” which matches anything.</p></li>
<li><p>A pattern of the form <code>x@pat</code> can be used to match a value against the pattern <code>pat</code>, but <em>also</em> give the name <code>x</code> to the entire value being matched. For example:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">baz ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
baz p<span class="fu">@</span>(<span class="dt">Person</span> n _ _) <span class="fu">=</span> <span class="st">"The name field of ("</span> <span class="fu">++</span> show p <span class="fu">++</span> <span class="st">") is "</span> <span class="fu">++</span> n</code></pre>
<pre><code>*Main&gt; baz richard
"The name field of (Person \"Richard\" 32 Ship) is Richard"
</code></pre></li>
<li><p>Patterns can be <em>nested</em>. For example:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">checkFav ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
checkFav (<span class="dt">Person</span> n _ <span class="dt">Ship</span>) <span class="fu">=</span> n <span class="fu">++</span> <span class="st">", you're my kind of person!"</span>
checkFav (<span class="dt">Person</span> n _ _)    <span class="fu">=</span> n <span class="fu">++</span> <span class="st">", your favorite thing is lame."</span></code></pre>
<pre><code>*Main&gt; checkFav richard
"Richard, you're my kind of person!"
*Main&gt; checkFav stan
"Stan, your favorite thing is lame."
</code></pre>
<p>Note how we nest the pattern <code>SealingWax</code> inside the pattern for <code>Person</code>.</p></li>
</ol>
<p>In general, the following grammar defines what can be used as a pattern:</p>
<pre><code>pat ::= _
     |  var
     |  var @ ( pat )
     |  ( Constructor pat1 pat2 ... patn )
</code></pre>
<p>The first line says that an underscore is a pattern. The second line says that a variable by itself is a pattern: such a pattern matches anything, and “binds” the given variable name to the matched value. The third line specifies <code>@</code>-patterns. The last line says that a constructor name followed by a sequence of patterns is itself a pattern: such a pattern matches a value if that value was constructed using the given constructor, <em>and</em> <code>pat1</code> through <code>patn</code> all match the values contained by the constructor, recursively.</p>
<p>(In actual fact, the full grammar of patterns includes yet more features still, but the rest would take us too far afield for now.)</p>
<p>Note that literal values like <code>2</code> or <code>'c'</code> can be thought of as constructors with no arguments. It is as if the types <code>Int</code> and <code>Char</code> were defined like</p>
<pre><code>data Int  = 0 | 1 | -1 | 2 | -2 | ...
data Char = 'a' | 'b' | 'c' | ...
</code></pre>
<p>which means that we can pattern-match against literal values. (Of course, <code>Int</code> and <code>Char</code> are not <em>actually</em> defined this way.)</p>
<h2 id="case-expressions">Case expressions</h2>
<p>The fundamental construct for doing pattern-matching in Haskell is the <code>case</code> expression. In general, a <code>case</code> expression looks like</p>
<pre><code>case exp of
  pat1 -&gt; exp1
  pat2 -&gt; exp2
  ...
</code></pre>
<p>When evaluated, the expression <code>exp</code> is matched against each of the patterns <code>pat1</code>, <code>pat2</code>, … in turn. The first matching pattern is chosen, and the entire <code>case</code> expression evaluates to the expression corresponding to the matching pattern. For example,</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">ex03 <span class="fu">=</span> <span class="kw">case</span> <span class="st">"Hello"</span> <span class="kw">of</span>
           []      <span class="ot">-&gt;</span> <span class="dv">3</span>
           (<span class="ch">'H'</span><span class="fu">:</span>s) <span class="ot">-&gt;</span> length s
           _       <span class="ot">-&gt;</span> <span class="dv">7</span></code></pre>
<p>evaluates to <code>4</code> (the second pattern is chosen; the third pattern matches too, of course, but it is never reached).</p>
<p>In fact, the syntax for defining functions we have seen is really just convenient syntax sugar for defining a <code>case</code> expression. For example, the definition of <code>failureToZero</code> given previously can equivalently be written as</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">failureToZero' ::</span> <span class="dt">FailableDouble</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
failureToZero' x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span>
                     <span class="dt">Failure</span> <span class="ot">-&gt;</span> <span class="dv">0</span>
                     <span class="dt">OK</span> d    <span class="ot">-&gt;</span> d</code></pre>
<h2 id="polymorphic-data-types">Polymorphic data types</h2>
<p>Let’s take a look at (almost) two of the data structures from HW3:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">LogMessage</span> <span class="fu">=</span> <span class="dt">LogMessage</span> <span class="dt">Int</span> <span class="dt">String</span>
<span class="kw">data</span> <span class="dt">MaybeLogMessage</span> <span class="fu">=</span> <span class="dt">ValidLM</span> <span class="dt">LogMessage</span>
                     <span class="fu">|</span> <span class="dt">InvalidLM</span>
<span class="kw">data</span> <span class="dt">MaybeInt</span> <span class="fu">=</span> <span class="dt">ValidInt</span> <span class="dt">Int</span>
              <span class="fu">|</span> <span class="dt">InvalidInt</span></code></pre>
<p>Those last two data structures are awfully similar. They both represent the possibility of failure. That is, they both optionally hold some type <code>a</code>; first, <code>a</code> is instantiated to <code>LogMessage</code>, and then to <code>Int</code>. It turns out that we can write this more directly:</p>
<pre><code>data Maybe a = Just a
             | Nothing
</code></pre>
<p>(This definition isn’t written using the <code>&gt;</code> marks because it’s part of the <code>Prelude</code>.)</p>
<p>A <code>Maybe a</code> is, possibly, an <code>a</code>. (<code>a</code> is called a <em>type variable</em> – it’s a variable that stands in for a <em>type</em>.) So, instead of <code>MaybeLogMessage</code>, we could use <code>Maybe LogMessage</code>, and instead of <code>MaybeInt</code>, could use <code>Maybe Int</code>. <code>Maybe</code> is a <em>type constructor</em> or <em>parameterized type</em>. To become a proper, full-blooded type, we must supply <code>Maybe</code> with another type, like <code>LogMessage</code> or <code>Int</code>. When we do so, we simply replace all uses of <code>a</code> in <code>Maybe</code>’s definition with the type chosen as the parameter. Thus, the <code>Just</code> constructor of <code>Maybe Int</code> takes an <code>Int</code> parameter, and the <code>Just</code> constructor of <code>Maybe LogMessage</code> takes a <code>LogMessage</code> parameter.</p>
<p>With the introduction of type constructors, it becomes useful to talk about the <em>type of a type</em>. This is called a kind. Any well-formed type in Haskell such as an <code>Int</code> or a <code>Bool</code> has kind <code>*</code>. A type constructor such as <code>Maybe</code> that takes a single type parameter has kind <code>* -&gt; *</code>. The type <code>Maybe Int</code> has kind <code>*</code> because it does not need any more type parameters in order to be a well-formed type. Everything in a type annotation must have kind <code>*</code>. For example, <code>Int -&gt; Maybe</code> is not a valid type for a function.</p>
<p>Here is some sample code:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">example_a ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
example_a (<span class="dt">Just</span> n) <span class="fu">=</span> n
example_a <span class="dt">Nothing</span>  <span class="fu">=</span> (<span class="fu">-</span><span class="dv">1</span>)

<span class="ot">example_b ::</span> <span class="dt">LogMessage</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span>
example_b (<span class="dt">LogMessage</span> severity s) <span class="fu">|</span> severity <span class="fu">&gt;=</span> <span class="dv">50</span> <span class="fu">=</span> <span class="dt">Just</span> s
example_b _                                        <span class="fu">=</span> <span class="dt">Nothing</span></code></pre>
<p>We’re quite used to thinking about substituting terms in for other terms (that’s what we use variables for!), and here we just apply this same principle to types.</p>
<h2 id="recursive-data-types">Recursive data types</h2>
<p>Data types can be <em>recursive</em>, that is, defined in terms of themselves. In fact, we have already seen a recursive type—the type of lists. A list is either empty, or a single element followed by a remaining list. We could define our own list type like so:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> t <span class="fu">=</span> <span class="dt">Empty</span> <span class="fu">|</span> <span class="dt">Cons</span> t (<span class="dt">List</span> t)</code></pre>
<p>Given a type <code>t</code>, a <code>(List t)</code> consists of either the constructor <code>Empty</code>, or the constructor <code>Cons</code> along with a value of type <code>t</code> and another <code>(List t)</code>. Here are some examples:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">lst1 ::</span> <span class="dt">List</span> <span class="dt">Int</span>
lst1 <span class="fu">=</span> <span class="dt">Cons</span> <span class="dv">3</span> (<span class="dt">Cons</span> <span class="dv">5</span> (<span class="dt">Cons</span> <span class="dv">2</span> <span class="dt">Empty</span>))

<span class="ot">lst2 ::</span> <span class="dt">List</span> <span class="dt">Char</span>
lst2 <span class="fu">=</span> <span class="dt">Cons</span> <span class="ch">'x'</span> (<span class="dt">Cons</span> <span class="ch">'y'</span> (<span class="dt">Cons</span> <span class="ch">'z'</span> <span class="dt">Empty</span>))

<span class="ot">lst3 ::</span> <span class="dt">List</span> <span class="dt">Bool</span>
lst3 <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">True</span> (<span class="dt">Cons</span> <span class="dt">False</span> <span class="dt">Empty</span>)</code></pre>
<p>This <code>List</code> type is exactly like the built-in list type, only without special syntax. In fact, when you say <code>[Int]</code> in a type, that really means <code>[] Int</code> – allowing you to put the brackets around the <code>Int</code> is just a nice syntactic sugar.</p>
<p>We often use recursive functions to process recursive data types:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">intListProd ::</span> <span class="dt">List</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
intListProd <span class="dt">Empty</span>      <span class="fu">=</span> <span class="dv">1</span>
intListProd (<span class="dt">Cons</span> x l) <span class="fu">=</span> x <span class="fu">*</span> intListProd l</code></pre>
<p>As another simple example, we can define a type of binary trees with an <code>Int</code> value stored at each internal node, and a <code>Char</code> stored at each leaf:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dt">Char</span>
          <span class="fu">|</span> <span class="dt">Node</span> <span class="dt">Tree</span> <span class="dt">Int</span> <span class="dt">Tree</span>
  <span class="kw">deriving</span> <span class="dt">Show</span></code></pre>
<p>(Don’t ask me what you would use such a tree for; it’s an example, OK?) For example,</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">tree ::</span> <span class="dt">Tree</span>
tree <span class="fu">=</span> <span class="dt">Node</span> (<span class="dt">Leaf</span> <span class="ch">'x'</span>) <span class="dv">1</span> (<span class="dt">Node</span> (<span class="dt">Leaf</span> <span class="ch">'y'</span>) <span class="dv">2</span> (<span class="dt">Leaf</span> <span class="ch">'z'</span>))</code></pre>
<hr>
<p><code>Generated 2015-03-04 09:21:44.198466</code></p>

    </div>

    <div id="footer"><center>
      <font size="-2">Powered
      by <a href="http://community.haskell.org/~ndm/shake/">shake</a>,
      <a href="http://jaspervdj.be/hakyll/index.html">hakyll</a>,
      <a href="http://johnmacfarlane.net/pandoc/">pandoc</a>,
      <a href="http://projects.haskell.org/diagrams">diagrams</a>,
      and <a href="http://www.andres-loeh.de/lhs2tex/">lhs2TeX</a>.
      </font></center><font size="-2">
    </font></div><font size="-2">
  </font></div><font size="-2">



</font></body></html>