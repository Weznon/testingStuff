data Dir = L | R | U | D

instance Show Dir where
  show L = "L"
  show R = "R"
  show U = "U"
  show D = "D"

instance Eq Dir where
  L == L = True
  R == R = True
  U == U = True
  D == D = True
  _ == _ = False

parseIns :: String -> [Dir]
parseIns [] = []
parseIns (x:xs)
  | x == 'L' = [(L)] ++ parseIns xs
  | x == 'R' = [(R)] ++ parseIns xs
  | x == 'U' = [(U)] ++ parseIns xs
  | x == 'D' = [(D)] ++ parseIns xs
  | otherwise = error "someting is wrong in input"

parseComplete :: String -> ([Dir], [Dir], [Dir], [Dir], [Dir])
parseComplete x = (parseIns (moo !! 0), parseIns (moo !! 1), parseIns (moo !! 2), parseIns (moo !! 3), parseIns (moo !! 4))
  where moo = lines x

input :: String
input = "LURLDDLDULRURDUDLRULRDLLRURDUDRLLRLRURDRULDLRLRRDDULUDULURULLURLURRRLLDURURLLUURDLLDUUDRRDLDLLRUUDURURRULURUURLDLLLUDDUUDRULLRUDURRLRLLDRRUDULLDUUUDLDLRLLRLULDLRLUDLRRULDDDURLUULRDLRULRDURDURUUUDDRRDRRUDULDUUULLLLURRDDUULDRDRLULRRRUUDUURDULDDRLDRDLLDDLRDLDULUDDLULUDRLULRRRRUUUDULULDLUDUUUUDURLUDRDLLDDRULUURDRRRDRLDLLURLULDULRUDRDDUDDLRLRRDUDDRULRULULRDDDDRDLLLRURDDDDRDRUDUDUUDRUDLDULRUULLRRLURRRRUUDRDLDUDDLUDRRURLRDDLUUDUDUUDRLUURURRURDRRRURULUUDUUDURUUURDDDURUDLRLLULRULRDURLLDDULLDULULDDDRUDDDUUDDUDDRRRURRUURRRRURUDRRDLRDUUULLRRRUDD\nDLDUDULDLRDLUDDLLRLUUULLDURRUDLLDUDDRDRLRDDUUUURDULDULLRDRURDLULRUURRDLULUDRURDULLDRURUULLDLLUDRLUDRUDRURURUULRDLLDDDLRUDUDLUDURLDDLRRUUURDDDRLUDDDUDDLDUDDUUUUUULLRDRRUDRUDDDLLLDRDUULRLDURLLDURUDDLLURDDLULLDDDRLUDRDDLDLDLRLURRDURRRUDRRDUUDDRLLUDLDRLRDUDLDLRDRUDUUULULUDRRULUDRDRRLLDDRDDDLULURUURULLRRRRRDDRDDRRRDLRDURURRRDDULLUULRULURURDRRUDURDDUURDUURUURUULURUUDULURRDLRRUUDRLLDLDRRRULDRLLRLDUDULRRLDUDDUUURDUDLDDDUDL\nRURDRUDUUUUULLLUULDULLLDRUULURLDULULRDDLRLLRURULLLLLLRULLURRDLULLUULRRDURRURLUDLULDLRRULRDLDULLDDRRDLLRURRDULULDRRDDULDURRRUUURUDDURULUUDURUULUDLUURRLDLRDDUUUUURULDRDUDDULULRDRUUURRRDRLURRLUUULRUDRRLUDRDLDUDDRDRRUULLLLDUUUULDULRRRLLRLRLRULDLRURRLRLDLRRDRDRLDRUDDDUUDRLLUUURLRLULURLDRRULRULUDRUUURRUDLDDRRDDURUUULLDDLLDDRUDDDUULUDRDDLULDDDDRULDDDDUUUURRLDUURULRDDRDLLLRRDDURUDRRLDUDULRULDDLDDLDUUUULDLLULUUDDULUUDLRDRUDLURDULUDDRDRDRDDURDLURLULRUURDUDULDDLDDRUULLRDRLRRUURRDDRDUDDLRRLLDRDLUUDRRDDDUUUDLRRLDDDUDRURRDDUULUDLLLRUDDRULRLLLRDLUDUUUUURLRRUDUDDDDLRLLULLUDRDURDDULULRDRDLUDDRLURRLRRULRL\nLDUURLLULRUURRDLDRUULRDRDDDRULDLURDDRURULLRUURRLRRLDRURRDRLUDRUUUULLDRLURDRLRUDDRDDDUURRDRRURULLLDRDRDLDUURLDRUULLDRDDRRDRDUUDLURUDDLLUUDDULDDULRDDUUDDDLRLLLULLDLUDRRLDUUDRUUDUDUURULDRRLRRDLRLURDRURURRDURDURRUDLRURURUUDURURUDRURULLLLLUDRUDUDULRLLLRDRLLRLRLRRDULRUUULURLRRLDRRRDRULRUDUURRRRULDDLRULDRRRDLDRLUDLLUDDRURLURURRLRUDLRLLRDLLDRDDLDUDRDLDDRULDDULUDDLLDURDULLDURRURRULLDRLUURURLLUDDRLRRUUDULRRLLRUDRDUURLDDLLURRDLRUURLLDRDLRUULUDURRDULUULDDLUUUDDLRRDRDUDLRUULDDDLDDRUDDD\nDRRDRRURURUDDDRULRUDLDLDULRLDURURUUURURLURURDDDDRULUDLDDRDDUDULRUUULRDUDULURLRULRDDLDUDLDLULRULDRRLUDLLLLURUDUDLLDLDRLRUUULRDDLUURDRRDLUDUDRULRRDDRRLDUDLLDLURLRDLRUUDLDULURDDUUDDLRDLUURLDLRLRDLLRUDRDUURDDLDDLURRDDRDRURULURRLRLDURLRRUUUDDUUDRDRULRDLURLDDDRURUDRULDURUUUUDULURUDDDDUURULULDRURRDRDURUUURURLLDRDLDLRDDULDRLLDUDUDDLRLLRLRUUDLUDDULRLDLLRLUUDLLLUUDULRDULDLRRLDDDDUDDRRRDDRDDUDRLLLDLLDLLRDLDRDLUDRRRLDDRLUDLRLDRUURUDURDLRDDULRLDUUUDRLLDRLDLLDLDRRRLLULLUDDDLRUDULDDDLDRRLLRDDLDUULRDLRRLRLLRUUULLRDUDLRURRRUULLULLLRRURLRDULLLRLDUUUDDRLRLUURRLUUUDURLRDURRDUDDUDDRDDRUD"

count :: (Int, Int, Int, Int) -> [Dir] -> (Int, Int, Int, Int)
count x [] = x
count (q, w, e, r) (x:xs)
  |x == L = count (q + 1, w, e, r) xs
  |x == R = count (q, w + 1, e, r) xs
  |x == U = count (q, w, e + 1, r) xs
  |x == D = count (q, w, e, r + 1) xs

counted (q, w, e, r, t) = (count base q, count base w, count base e, count base r, count base t)
  where base = (0, 0, 0, 0)

interpret :: (Int, Int, Int, Int) -> (Int, Int)
interpret (q, w, e, r) = (q - w, e - r)

merp (q, w, e, r, t) = (interpret q, interpret w, interpret e, interpret r, interpret t)

input2 :: String
input2 = "ULL\nRRDDD\nLURDL\nUUUUD"
--0,0 is middle so 7
--     1
--   2 3 4
-- 5 6 7 8 9
--   A B C
--     D
--9, 1, 8, 1, 4
--not it, sadly
--not sure why
--main outputs the values that lead to that
--9d8bc
next :: (Int, Int) -> Dir -> (Int, Int)
next (x, y) R
  | (x == 0 && (y == 2 || y == -2) || x == 1 && (y == 1 || y == -1) || x == 2 && y == 0) = (x, y)
  |otherwise = (x + 1, y)
next (x, y) L
  | (x == 0 || (y == 2 || y == -2) || x == -1 && (y == 1 || y == -1) || x == -2 && y == 0) = (x, y)
  |otherwise = (x - 1, y)
next (x, y) U
  | (y == 0 && (x == 2 || x == -2) || y == 1 && (x == -1 || x == 1) || y == 2 && x == 0) = (x, y)
  |otherwise = (x, y + 1)
next (x, y) D
  | (y == 0 && (x == 2 || x == -2) || y == -1 && (x == -1 || x == 1) || y == -2 && x == 0)  = (x, y)
  |otherwise = (x, y - 1)

findNum :: (Int, Int) -> [Dir] -> (Int, Int)
findNum x [] = x
findNum x (d:ds) = findNum num ds
  where num = next x d

answer :: (Int, Int) -> ([Dir], [Dir], [Dir], [Dir], [Dir]) -> ((Int, Int), (Int, Int), (Int, Int), (Int, Int), (Int, Int))
answer x (q, w, e, r, t) = (dO, dT, dH, dF, dI)
  where dO = findNum x q
        dT = findNum dO w
        dH = findNum dT e
        dF = findNum dH r
        dI = findNum dF t

main :: IO()
main = do
  xs <- readFile "input"
  print $ answer (-2, 0) (parseComplete $ xs)

--Not 9728, 9728 is too low. Actual answer is higher
--Not 9728, 9728 is too low. Actual answer is higher
--Not 9728, 9728 is too low. Actual answer is higher
